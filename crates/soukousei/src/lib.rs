use crate::env::EnvProvider;
use miette::{Diagnostic, IntoDiagnostic, Report};
use serde::{Deserialize, Deserializer};
use std::fmt::{Display, Formatter, Write};
use thiserror::Error;

pub use miette;

pub mod env {
    use miette::{miette, Report};
    use std::ffi::OsString;

    pub trait EnvProvider {
        fn fetch(&self, key: impl AsRef<str>) -> Result<Option<String>, Report>;

        fn fetch_from_arr<const N: usize>(
            &self,
            arr: [&'static str; N],
        ) -> Result<Option<(String, &'static str)>, Report> {
            for var_name in arr {
                let found = self.fetch(var_name)?;
                if let Some(found) = found {
                    return Ok(Some((found, var_name)));
                };
            }
            Ok(None)
        }
    }

    pub struct StdEnv;

    impl StdEnv {
        pub fn new() -> Self {
            Self
        }
    }

    impl EnvProvider for StdEnv {
        fn fetch(&self, key: impl AsRef<str>) -> Result<Option<String>, Report> {
            use std::env::{var, VarError};

            match var(key.as_ref()) {
                Ok(x) => Ok(Some(x)),
                Err(VarError::NotPresent) => Ok(None),
                Err(VarError::NotUnicode(os)) => {
                    // TODO: make a special diagnostic for this error
                    Err(miette!(
                        "ENV var `{}` is not a valid utf-8 string: {:?}",
                        key.as_ref(),
                        os
                    ))
                }
            }
        }
    }
}

pub mod sources {
    pub struct Json;

    trait FromFile {}
}

/// Common trait for configuration partials. Its implementation is generated by [`Config`] macro.
pub trait Layer {
    type Complete;

    /// Construct a partial with all empty fields.
    fn new() -> Self;

    /// Construct a partial with default values.
    ///
    /// TODO: move to `Default` trait?
    fn default() -> Self;

    // /// Construct a partial from a [`Deserializer`]
    // fn parse<'de, D>(deserializer: D) -> Result<Self, ParseError>
    // where
    //     D: Deserializer<'de>,
    //     Self: Deserialize<'de>;

    // /// Construct a partial from environment variables.
    // fn from_env(provider: &impl EnvProvider) -> Result<Self, Report>
    // where
    //     Self: Sized;

    /// Merge a partial with another partial.
    ///
    /// Merge strategies might be customised through macro attributes. (TODO)
    fn merge(self, other: Self) -> Self;

    /// "Unwrap" a partial with all required fields presented as actual values instead
    /// of [`Option`]s.
    fn complete(self) -> Result<Self::Complete, MissingFieldsError>;

    // /// Shorthand for parsing the same partial ([`Self::parse`]) and merging the result
    // /// ([`Self::merge`]).
    // fn parse_and_merge<'de, D>(self, deserializer: D) -> Result<Self, ParseError>
    // where
    //     D: Deserializer<'de>,
    //     Self: Deserialize<'de>,
    // {
    //     Self::parse(deserializer).map(|parsed| self.merge(parsed))
    // }
    //
    // /// Shorthand for parsing the same partial from env ([`Self::from_env`]) and merging
    // /// the result ([`Self::merge`]).
    // fn parse_env_and_merge<P, E>(self, provider: P) -> Result<Self, E>
    // where
    //     Self: Sized,
    //     P: env::EnvProvider<FetchError = E>,
    // {
    //     Self::from_env(provider).map(|parsed| self.merge(parsed))
    // }
}

// pub trait MapProvider {
//
// }
//
// pub trait FromMap<T> {
//
// }

pub trait HasLayer {
    type Layer: Layer<Complete = Self>;
}

// pub struct DefaultLayer<T>(Option<T>);
//
// pub trait LayerComplete {
//     type Complete;
// }
//
// impl<T> Layer for DefaultLayer<Option<T>> {
//     type Complete = Option<T>;
//
//     fn new() -> Self {
//         Self(None)
//     }
//
//     fn merge(self, other: Self) -> Self {
//         todo!()
//     }
// }
//
// impl<T> Layer for DefaultLayer<T> {
//     type Complete = T;
//
//     fn new() -> Self {
//         Self(None)
//     }
//
//     fn default() -> Self {
//         Self(None)
//     }
//
//     fn merge(self, other: Self) -> Self {
//         Self(other.0.or(self.0))
//     }
//
//     // fn from_env(provider: &impl EnvProvider) -> Result<Self, Report> where Self: Sized {
//     //     todo!()
//     // }
//
//     fn complete(self) -> Result<Self::Complete, MissingFieldsError> {
//         self.0.ok_or_else(|| MissingFieldsError::dummy())
//     }
// }
//
// impl<T> DefaultLayer<T> {
//     pub fn default_custom(value: T) -> Self {
//         Self(Some(value))
//     }
// }

#[derive(Error, Debug)]
pub struct MissingFieldsError {
    paths: Vec<Vec<&'static str>>, // Dummy,
                                   // Single(&'static str),
                                   // Multiple(Vec<MissingFieldsError>),
                                   // Nested {
                                   //     loc: &'static str,
                                   //     deeper: Box<MissingFieldsError>,
                                   // }, // fields: Vec<&'static str>,
}

// #[derive(Error, Debug, Diagnostic)]
// struct MissingFieldsErrorDiagnostic {
//     paths: Vec<Vec<&'static str>>,
// }

impl Display for MissingFieldsError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("Missing required fields: ")?;

        for (i, field_path_reversed) in self.paths.iter().enumerate() {
            if i > 0 {
                f.write_str(", ")?;
            }
            f.write_str("`")?;
            for (i, loc) in field_path_reversed.iter().rev().enumerate() {
                if i > 0 {
                    f.write_str(".")?;
                }
                f.write_str(loc)?;
            }
            f.write_str("`")?;
        }
        Ok(())
    }
}

impl<T> IntoDiagnostic<T, MissingFieldsError> for MissingFieldsError {
    fn into_diagnostic(self) -> Result<T, Report> {
        todo!()
    }
}

impl MissingFieldsError {
    /// Empty missing fields accumulator
    pub fn dummy() -> Self {
        Self { paths: Vec::new() }
    }

    pub fn add_field(&mut self, loc: &'static str) {
        self.paths.push(vec![loc]);
    }

    pub fn nest(&mut self, loc: &'static str, other: Self) {
        for mut nested_path in other.paths.into_iter() {
            nested_path.push(loc);
            self.paths.push(nested_path);
        }
    }

    /// `Ok(())` if empty, `Err(Self)` otherwise
    pub fn result(self) -> Result<(), Self> {
        if self.paths.len() > 0 {
            Err(self)
        } else {
            Ok(())
        }
    }

    // fn concat(mut self, other: Self) -> Self {
    //     match self {
    //         Self::Multiple(mut vec) => {
    //             vec.push(other);
    //             Self::Multiple(vec)
    //         }
    //         not_multiple => Self::Multiple(vec![not_multiple, other]),
    //     }
    // }
}

// #[derive(Debug)]
// pub enum MissingFields {
//     Single(MissingField),
//     Multiple(Vec<MissingField>),
// }
//
// impl MissingFields {
//     pub fn multiple(fields: Vec<MissingField>) -> Self {
//         Self::Multiple(fields)
//     }
// }
//
// #[derive(Debug)]
// pub struct MissingField {
//     path: Vec<&'static str>,
// }
//
// impl MissingField {
//     pub fn named(loc: &'static str) -> Self {
//         Self { path: vec![loc] }
//     }
//
//     pub fn anonymous() -> Self {
//         Self { path: Vec::new() }
//     }
//
//     pub fn nest(mut self, loc: &'static str) -> Self {
//         self.path.push(loc);
//         self
//     }
// }
//
// impl From<MissingField> for MissingFields {
//     fn from(value: MissingField) -> Self {
//         Self::Single(value)
//     }
// }
//
// pub trait MissingFieldResultExt {
//     fn nest(self, loc: &'static str) -> Self;
// }
//
// impl<T> MissingFieldResultExt for Result<T, MissingField> {
//     fn nest(self, loc: &'static str) -> Self {
//         self.map_err(|err| err.nest(loc))
//     }
// }
